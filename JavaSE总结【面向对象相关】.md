1.面向对象与面向过程
两者都是软件开发思想，先有面向过程，后有面向对象。在大型项目中，针对面向过程的不足推出了面向对象开发思想。比喻蒋介石和Mao泽东分别是面向过程和面向对象的杰出代表，这样充分说明，在解决复制问题时，面向对象有更大的优越性。面向过程是蛋炒饭，面向对象是盖浇饭。盖浇饭的好处就是“菜”“饭”分离，从而提高了制作盖浇饭的灵活性。饭不满意就换饭，菜不满意换菜。用软件工程的专业术语就是“可维护性”比较好，“饭” 和“菜”的耦合度比较低。

区别
编程思路不同： 面向过程以实现功能的函数开发为主，而面向对象要首先抽象出类、属性及其方法，然后通过实例化类、执行方法来完成功能。
封装性：都具有封装性，但是面向过程是封装的是功能，而面向对象封装的是数据和功能。
面向对象具有继承性和多态性，而面向过程没有继承性和多态性，所以面向对象优势是明显。

对象泛指现实中一切事物，每种事物都具备自己的属性和行为。面向对象思想就是在计算机程序设计过程中，参照现实中事物，将事物的属性特征、行为特征抽象出来，描述成计算 机事件的设计思想。
它区别于面向过程思想，强调的是通过调用对象的行为来实现功能，而不是自己一步一步的去 操作实现。

2.面向对象特点：封装、继承和多态
封装：将对象的属性和行为封装起来，不需要让外界知道程序的具体实现细节，这就是封装思想。【体现：private关键字和setXxx()方法】
继承：主要描述类与类之间的关系。通过继承，可以在无须重新编写原有类的情况下对原有类的功能进行扩展。增强代码的的复用性。
多态：在一个类中定义的属性和功能被其他类继承后，当把子类对象直接赋值给父类引用变量时，相同引用类型的变量调用同一方法所呈现出的多种不同行为特性。

3.访问控制符
控制级别由小到大依次列出：private、default、protected和public。
private(当前类访问级别):如果类的成员被private访问控制符来修饰，则这个成员只能被该类的其他成员访问，其他类无法直接访问。类的良好封装就是通过private关键字来实现的。
default(包访问级别):如果一个类或一个类的成员不使用任何访问控制符修饰，则称它为默认访问控制级别，这个类或类的成员只能被本包中的其他类访问。
protected(子类访问级别):如果一个类的成员被protected访问控制符修饰，那么这个成员既能被同一包下的其他类访问，也能被不同包下该类的子类访问。
public(公共访问级别):如果一个类或一个类的成员被public访问控制符修饰，那么这个类或者类的成员能被所有的类访问，不管访问类与被访问类是否在同一包中。

4.成员变量和局部变量的区别
1)定义的位置不同。
成员变量定义在类当中方法外。局部变量定义在方法内部。
2)作用的范围不同。
成员变量在整个类中可以通用。局部变量只可以在方法中使用，出了方法就不能使用。
3)默认值不一样。
成员变量没有赋值，会有默认值，规则和数组一样。
局部变量没有默认值，如果要使用，必须手动进行赋值。
4)内存位置不同。
成员变量位于堆内存。局部变量位于栈内存。
5)生命周期不同。
成员变量随对象创建而诞生，随对象被垃圾回收而消失。
局部变量随方法进栈而诞生，随方法出栈而消失。

5. 重载（Overload）和重写（Override）区别
**重载（Overload）**是让类以统一的方式处理不同类型数据。方法的重载与返回值类型无关，它只需要满足两个条件：一是方法名相同，二是参数个数或参数类型不同。
**重写（Override）**是父类与子类之间的多态性，实质是对父类的函数进行重新定义。需要注意的是，**子类中重写的方法需要和父类中被重写的方法具有相同的返回值类型、方法名和参数列表。子类重写父类方法时，不能使用比父类中被重写的方法更严格的访问权限。**如父类中的方法访问权限是public，子类重写父类该方法的访问权限就不能是private。

6.构造方法：完成对象的初始化。（亦可重载）
实例化一个对象后，如果要对这个对象的属性赋值，则必须访问对象的属性，或调用setXxx（）方法。如果需要在实例化对象的同时就为这个对象的属性进行赋值，可以通过构造方法来实现。构造方法（也被称为构造器）是类的一个特殊成员，它会在类实例化对象时被自动调用。

条件：
1>方法名与类名相同；
2>在方法名的前面没有返回值的类型；
3>在方法中不能使用return语句返回一个值，但是可以单独写return语句来作为方法的结束。

注意：
1>在Java的每一个类都至少有一个构造方法，如果在一个类中没有显式地定义构造方法，系统会自动为这个类创建一个默认的构造方法，这个默认的构造方法没有参数，在其方法体中没有任何代码，即什么都不做。自己一旦为类定义构造方法，系统将不再提供默认的无参构造方法。
2>声明构造方法时，可以使用private访问修饰符吗？
被private访问修饰符修饰的构造方法只能在当前类中被访问，无法在类的外部被访问，也就无法通过该私有构造方法来创建对象。因此为了方便实例化对象，构造方法通常会使用public来修饰。

7.this关键字
1>通过this关键字调用成员变量，解决与局部变量名称冲突的问题。在类中方法访问类中属性，就一定要加上this关键字；
2>通过this关键字调用成员方法。此处的this关键字可以省略不写；
3>通过this关键字调用构造方法。构造方法是在实例化对象时被JVM自动调用的，在程序中不能像调用其它方法一样去调用构造方法。但可以在一个构造方法中使用this（[参数1，参数2…]）的形成来调用其它构造方法。如果类中有多个构造方法，系统将自动根据this()的参数个数和参数类型找出类中相匹配的构造器。

注意：
1>只能造构造器中使用this调用其它的构造方法，不能在成员方法中调用其它的构造方法；
2>在构造方法中，使用this调用构造方法的语句必须是该方法的第一条执行语句，且只能出现一次；
3>不能在一个类的两个构造方法中使用this互相调用。

8.static关键字
1>static类属性（静态变量）
static关键字只能用于修饰成员变量，不能用于修饰局部变量，static修饰的成员变量被叫做静态变量，它可以被所有实例所共享，使用类名.变量名访问。
结论：
访问static属性（类属性）应使用类名称.属性名。
所有的非static属性（实例变量）必须在对象实例化后使用，而static属性（类属性）不受对象实例化控制。
传统属性所具备的特征：保存在堆内存中，且每个对象独享属性。
【描述共享属性，只需在属性前添加static关键字即可。static属性又被称为类属性，保存在全局数据区的内存之中，所有对象都可以进行该数据区的访问】

2>static类方法（静态方法）
注意：在一个静态方法中只能访问static修饰的成员，原因在于没有被static修饰的成员变量需要创建对象才能访问，而静态方法在被调用时不创建任何对象。
关于static方法有以下两点说明：
<1>所有的static方法不允许调用非static定义的属性或方法；
<2>所有的非static方法允许访问static方法或属性。
使用static定义方法只有一个目的：某些方法不希望受到对象的控制，即可以在没有实例化对象的时候执行（广泛存在于工具类中）

3>静态代码块：当类被加载时，静态代码块会执行，由于类只加载一次，因此静态代码块也只执行一次。
即使main方法中创建两个对象，但是在两次实例化对象的过程中，静态代码块中的内容只输出了一次，这就说明静态代码块在类第一次使用时才会被加载，并且只会加载一次。

9.super关键字：访问父类的成员。
当子类重写父类的方法后，子类对象将无法直接访问父类被重写的方法。为了解决这个问题，在Java中专门提供了一个super关键字来访问父类的成员。

用法：
1)使用super关键字调用父类的成员变量和成员方法。
super.成员变量
super.成员方法（[参数1，参数2...]）
1
2
2)使用super关键字调用父类的构造方法。
super([参数1，参数2...])
1
注意1：通过super调用父类构造方法的代码必须位于子类构造方法的第一行，并且只能出现一次，否则程序在编译期间就会报错。
注意2：在子类的构造方法中一定会调用父类的某个构造方法。这时可以在子类的构造方法中通过super关键字指定调用父类的哪个构造方法，如果没有指定，在实例化子类对象时，会默认调用父类无参的构造方法。

10.final关键字
特性：
final修饰的类不能被继承。
final修饰的方法不能被子类重写。
final修饰的变量是常量，只能赋值一次。(final修饰的成员变量必须在声明的同时进行赋值，否则编译错误。final修饰的局部变量，可以先声明，再进行一次赋值。)

提问1：Java中为什么ststic中不能使用this关键字？
static方法是类方法，先于任何实例对象存在。即在类加载时就已经存在了，（Java虚拟机初始化时），但是对象是在创建时才在内存中生成。而this指代的是当前的对象。【程序启动时会为static方法分配一块空间，没有static的其它方法，非静态方法必须在类实例化时才有内存空间，所以在实例化之前是无法调用的。】
this指针是指向类的对象，在实例化对象时JVM会在堆区分配内存给一个具体的对象，this指向这个对象。而类中的static或始终是在静态区分配内存，this指向堆区，不能调用。static属于类，this是对象指针。
super代表子类对父类构造方法的初始化，也是需要对象才可以使用，但是考虑到JVM加载顺序为先加载类，当被实例化才产生对象。所以如果并存则表示类和对象同时加载，显然不合逻辑。

提问2：构造方法和普通的成员方法有什么区别？
构造方法是类的一个特殊成员，它会在类实例化对象时被自动调用，而普通方法只有在使用的时候才会被调用。在定义构造方法时要求方法名与类名同名，在方法名前面没有返回值类型的声明，在方法中不能使用return返回一个值。

========================================================

1.抽象类
抽象类——当定义一个类时，常常需要定义一些方法来描述该类的行为特征，但有时这些方法的实现方式是无法确定的。针对这种情况，Java提供了抽象方法来满足这种需求。
抽象方法必须使用abstract关键字来修饰，并且在定义方法时不需要实现方法体。
当一个类中包含的抽象方法，那么该类也必须使用abstract关键字来修饰.
这种使用abstract关键字修饰的类就是抽象类。

注意：
包含抽象方法的类必须定义为抽象类，但抽象类中可以不包含任何抽象方法。
另外，抽象类是不可以被实例化的，因为抽象类中有可能包含抽象方法，抽象方法是没有方法体的，不可以被调用。
如果想要调用抽象类中定义的抽象方法，需要创建一个子类，在子类中实现抽象类中的抽象方法。
2.接口
接口是一种特殊的抽象类，它不能包含普通方法，其内部的所有方法都是抽象方法，它将抽象进行的更为彻底。
接口中除了抽象方法外，还可以有默认方法和静态方法（也叫类方法）。
默认方法使用default修饰，静态方法使用static修饰，并且这两种方法都允许有方法体。
与定义类不同的是，在定义接口时，不再使用static关键字，而是使用interface关键字来声明。

提示：
在接口中定义常量时，可以省略“public static final”修饰符，此时，接口会默认为常量添加“public static final”修饰符。
与此类似，在接口中定义抽象方法时，也可以省略“public abstract”修饰符。
定义default默认方法和static静态方法时，可以省略“public”修饰符，这些修饰符系统会默认进行添加。
调用格式：
静态方法可以通过“接口名.方法名”的形式来调用，而抽象方法和默认方法只能通过接口实现类的实例对象来调用。
一个类可以在继承另一个类的同时实现多个接口，并且多个接口之间需要使用英文,分隔。
接口和抽象类的异同之处
相同点

抽象类和接口均包含抽象方法，类必须实现所有的抽象方法，否则是抽象类。
抽象类和接口都不能实例化，他们位于继承树的顶端，用来被其他类继承和实现。
两者的区别主要体现在两方面：语法方面和设计理念方面

语法方面的区别是比较低层次的，非本质的，主要表现在：

接口中只能定义全局静态常量，不能定义变量。抽象类中可以定义常量和变量。
接口中所有的方法都是全局抽象方法。抽象类中可以有0个、1个或多个，甚至全部都是抽象方法。
抽象类中可以有构造方法，但不能用来实例化，而在子类实例化是执行，完成属于抽象类的初始化操作。接口中不能定义构造方法。
一个类只能有一个直接父类（可以是抽象类），但可以充实实现多个接口。一个类使用extends来继承抽象类，使用implements来实现接口。
二者的主要区别还是在设计理念上，其决定了某些情况下到底使用抽象类还是接口。

抽象类体现了一种继承关系，目的是复用代码，抽象类中定义了各个子类的相同代码，可以认为父类是一个实现了部分功能的“中间产品”，而子类是“最终产品”。父类和子类之间必须存在“is-a”的关系，即父类和子类在概念本质上应该是相同的。
接口并不要求实现类和接口在概念本质上一致的，仅仅是实现了接口定义的约定或者能力而已。接口定义了“做什么”，而实现类负责完成“怎么做”，体现了功能（规范）和实现分离的原则。接口和实现之间可以认为是一种“has-a的关系”
3.继承条件下构造方法的执行过程
继承条件下构造方法的调用规则如下：

如果子类的构造方法中没有通过super显式调用父类的有参构造方法，也没有通过this显式调用自身的其他构造方法，则系统会默认先调用父类的无参构造方法。在这种情况下，写不写“super();”语句，效果是一样的。
如果子类的构造方法中通过super显式调用父类的有参构造方法，那将执行父类相应构造方法，而不执行父类无参构造方法。
如果子类的构造方法中通过this显式调用自身的其他构造方法，在相应构造方法中应用以上两条规则。
特别注意的是，如果存在多级继承关系，在创建一个子类对象时，以上规则会多次向更高一级父类应用，一直到执行顶级父类Object类的无参构造方法为止。
4.多态的技能点（前提条件，向上转型、向下转型）
实现多态的三个条件

继承的存在；（继承是多态的基础，没有继承就没有多态）
子类重写父类的方法。（多态下会调用子类重写后的方法）
父类引用变量指向子类对象。（涉及子类到父类的类型转换）
向上转型 Student person = new Student()

将一个父类的引用指向一个子类对象，成为向上转型，自动进行类型转换。
此时通过父类引用变量调用的方法是子类覆盖或继承父类的方法，而不是父类的方法
此时通过父类引用变量无法调用子类特有的方法
向下转型 Student stu = (Student)person;

将一个指向子类对象的引用赋给一个子类的引用，成为向下转型，此时必须进行强制类型转换。
向下转型必须转换为父类引用指向的真实子类类型，，否则将出现ClassCastException，不是任意的强制转换
向下转型时可以结合使用instanceof运算符进行强制类型转换，比如出现转换异常。
5.==和equals的区别和联系
==
a) 基本类型，比较的是值
b) 引用类型，比较的是地址
c) 不能比较没有父子关系的两个对象

equals()
a) 系统类一般已经覆盖了equals()，比较的是内容。
b) 用户自定义类如果没有覆盖equals()，将调用父类的equals（比如是Object），而Object的equals的比较是地址（return (this == obj);）
c) 用户自定义类需要覆盖父类的equals()

注意：Object的==和equals比较的都是地址，作用相同
6.写出java.lang.Object类的六个常用方法
public boolean equals(java.lang.Object) 比较内容
public native int hashCode() 哈希码
public java.lang.String toString() 变成字符串
public final native java.lang.Class getClass() 获取类结构信息

protected void finalize() throws java.lang.Throwable 垃圾回收前执行的方法
protected native Object clone() throws java.lang.CloneNotSupportedException 克隆

public final void wait() throws java.lang.InterruptedException 多线程中等待功能
public final native void notify() 多线程中唤醒功能
public final native void notifyAll() 多线程中唤醒所有等待线程的功能
